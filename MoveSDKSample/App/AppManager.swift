/*
 *  Copyright 2023 Dolphin Technologies GmbH
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http:*www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 * /
 */

import DolphinMoveSDK
import Foundation
import AlertToast

/// The AppManager handles the communication with the server API
/// and manages user authentication
class AppManager: ObservableObject {
	/// Authentication Token Object.
	struct Authentication: Codable {
		var refreshToken: String
		var userToken: String
		var userID: String
	}

	/// The status of the app user token.
	///
	/// When it expires a new token must be fetched.
	/// The fetch can fail if the user loged in on another device.
	/// This can happen during any request.
	private enum TokenStatus {
		case aquired(Date)
		case loading
		case expired
		case failed

		var isLoading: Bool {
			switch self {
			case .loading: return true
			default: return false
			}
		}

		var isValid: Bool {
			switch self {
			case .aquired: return true
			default: return false
			}
		}

		var isFresh: Bool {
			switch self {
			case let .aquired(date): return -date.timeIntervalSinceNow < 60
			case .loading: return true
			default: return false
			}
		}
	}

	static let shared = AppManager()

	private let appid: String
	private let formatter: DateFormatter
	private let language: String
	private let platform = "iOS"
	private let version = Version.versionString

	private var pendingContinuations: [CheckedContinuation<Void, Error>] = []

	private var tokenStatus: TokenStatus = .aquired(.distantPast)

	private var auth: Authentication? { didSet { UserDefaults.standard.encode(auth, forKey: "auth") } }

	/// The UserID used for display.
	@Published var userID: String?

	/// A possible error, i.e: token expiry can happen from non UI requests.
	/// This error needs to be forwardable to the UI. See AppModel.
	@Published var errorMessage: String?

	/// Initialize persisted authentication object.
	init() {
		if let appid = UserDefaults.standard.string(forKey: "appid") {
			self.appid = appid
		} else {
			appid = UUID().uuidString
			UserDefaults.standard.set(appid, forKey: "appid")
		}

		auth = UserDefaults.standard.decode(forKey: "auth")

		userID = self.auth?.userID

		language = Bundle.main.preferredLocalizations.first ?? ""

		formatter = DateFormatter()
		formatter.calendar = Calendar(identifier: .iso8601)
		formatter.timeZone = TimeZone(secondsFromGMT: 0)
		formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss+00:00"
	}

	/// Standardize the request headers
	/// We ignore the optional header fields generated by the swagger API due to inconsistentcy.
	private func setupHeaders<ResponseType: APIResponseValue>(for request: APIRequest<ResponseType>, authenticated: Bool = true) {
		let date = formatter.string(from: Date())
		request.customHeaders["Accept-Language"] = language
		request.customHeaders["x-app-appid"] = appid
		request.customHeaders["x-app-appversion"] = version
		request.customHeaders["x-app-platform"] = platform
		request.customHeaders["Date"] = date

		guard let auth = self.auth else { return }
		request.customHeaders["x-app-contractid"] = "\(auth.userID)"

		guard authenticated else { return }
		request.customHeaders["Authorization"] = "Bearer \(auth.userToken)"
	}

	// MARK: async API

	/// Update the SDK token.
	/// - returns auth object with new refresh/user token
	/// - throws: network errors
	func updateSDKToken() async throws -> MoveAuth {
		return try await asyncAuthenticatedRequest { continuation in
			self.asyncUpdateSDKToken(continuation: continuation)
		}
	}

	/// Get user contract details.
	/// - returns contract object from server
	/// - throws: network errors
	func getUser() async throws -> ApiContract {
		return try await asyncAuthenticatedRequest { continuation in
			self.asyncGetUser(continuation: continuation)
		}
	}

	/// Get stored push messages from server.
	/// - returns: all push messages stored on the server including deleted ones with deleted flag
	/// - throws: network errors
	func requestMessages() async throws -> [ApiMessage] {
		return try await asyncAuthenticatedRequest { continuation in
			self.asyncRequestMessages(continuation: continuation)
		}
	}

	/// Store messages updates to server. The read/deleted flags are sent to the server.
	/// - parameters:
	///   - messages: message objects
	/// - throws: network errors
	func synchronizeMessages(_ messages: [Message]) async throws {
		try await asyncAuthenticatedRequest { continuation in
			self.asyncSynchronizeMessages(messages, continuation: continuation)
		}
	}

	/// Get timeline events.
	///	- parameters:
	///	  - from: start date
	///	  - to: end date
	///	- returns: user timeline events for specified time span
	/// - throws: network errors
	func getTimeline(from: Date, to: Date) async throws -> [ApiMoveTimelineItemBase] {
		return try await asyncAuthenticatedRequest { continuation in
			self.asyncGetTimeline(from: from, to: to, continuation: continuation)
		}
	}

	///	Get event details.
	///	- parameters:
	///	 - id: trip id
	///	 - returns: trip details
	/// - throws: network errors
	func getTripDetails(id: Int) async throws -> ApiMoveTimelineItemDetail {
		return try await asyncAuthenticatedRequest { continuation in
			self.asyncGetTripDetails(id: id, continuation: continuation)
		}
	}

	///	Set push token to receive push notifications.
	/// - parameters:
	///   - pushToken: push notification token
	/// - throws: network errors
	func setPushToken(_ pushToken: String) async throws {
		try await asyncAuthenticatedRequest { continuation in
			self.asyncSetPushToken(pushToken, continuation: continuation)
		}
	}

	/// Update user contract details.
	/// - parameters:
	///   - email: new email #optional
	///   - password: required for email change
	///   - gender: string "female"/"male"/"diverse"
	///   - firstname: first name
	///   - lastname: last name
	///   - phonennumber: phone number #optional
	///   - company: company name #optional
	/// - returns: update status string
	/// - throws: network errors
	func updateUser(email: String?, password: String?, gender: String, firstname: String, lastname: String, phonennumber: String?, company: String?) async throws -> String {
		if let email = email, let password = password {
			try await asyncAuthenticatedRequest { continuation in
				self.asyncUpdateUserEmail(email, password: password, gender: gender, firstname: firstname, lastname: lastname, phonennumber: phonennumber, company: company, continuation: continuation)
			}
			return "val_check_your_mailbox"
		} else {
			try await asyncAuthenticatedRequest { continuation in
				self.asyncUpdateUserProfile(gender: gender, firstname: firstname, lastname: lastname, phonennumber: phonennumber, company: company, continuation: continuation)
			}
			return "status_updated"
		}
	}

	/// Delete user contract.
	/// - parameters:
	///   - password: required to delete user
	/// - throws: network errors
	func deleteUser(password: String) async throws {
		try await asyncAuthenticatedRequest { continuation in
			self.asyncDeleteUser(password: password, continuation: continuation)
		}
		self.logout()
	}

	/// Login user.
	/// - parameters:
	///   - email: login
	///   - password: password
	/// - throws: network errors
	func login(email: String, password: String) async throws {
		let login = try await asyncRequest { continuation in
			self.asyncLogin(email: email, password: password, continuation: continuation)
		}
		guard let auth = getAuth(login: login) else {
			throw AppError.parserError
		}
		guard let sdkAuth = getSDKAuth(login: login) else {
			throw AppError.parserError
		}

		self.auth = auth

		tokenStatus = .aquired(Date())
		SDKManager.shared.authenticateSDK(auth: sdkAuth)

		DispatchQueue.main.async {
			self.userID = self.auth?.userID
		}
	}

	/// Register user.
	/// - parameters:
	///   - email: new email #optional
	///   - password: required for email change
	///   - gender: string "female"/"male"/"diverse"
	///   - firstname: first name
	///   - lastname: last name
	///   - phonennumber: phone number #optional
	///   - company: company name #optional
	/// - throws: network errors
	func register(gender: Int, firstname: String, lastname: String, phone: String?, company: String?, email: String, password: String) async throws {
		let login = try await asyncRequest { continuation in
			self.asyncRegister(gender: ProfileModel.Gender(gender).rawValue, firstname: firstname, lastname: lastname, phone: phone, company: company, email: email, password: password, continuation: continuation)
		}

		guard let auth = getAuth(login: login) else {
			throw AppError.parserError
		}
		guard let sdkAuth = getSDKAuth(login: login) else {
			throw AppError.parserError
		}

		self.auth = auth

		tokenStatus = .aquired(Date())
		SDKManager.shared.authenticateSDK(auth: sdkAuth)

		DispatchQueue.main.async {
			self.userID = self.auth?.userID
		}
	}

	/// Initiate forgot password process.
	/// - parameters:
	///   - email: login email address where email will be sent
	/// - throws: network errors
	func requestForgotPassword(email: String) async throws {
		try await asyncRequest { continuation in
			self.asyncRequestForgotPassword(email: email, continuation: continuation)
		}
	}

	/// Initiate change password process. Will send an email.
	///	- parameters:
	///   - old: current password
	///   - new: new password
	/// - throws: network errors
	func requestChangePassword(old: String, new: String) async throws {
		try await asyncRequest { continuation in
			self.asyncRequestChangePassword(old: old, new: new, continuation: continuation)
			self.logout()
		}
	}

	/// Logout user.
	func requestLogout() async {
		do {
			try await asyncAuthenticatedRequest { continuation in
				let body = ApiLogoutRequest(contractId: self.auth?.userID)
				let request = API.MoveUserRest.PostApiV1UsersLogout.Request(body: body)
				self.setupHeaders(for: request)
				request.makeRequest { response in
					/* logout no matter what error */
					self.logout()
					continuation.resume()
				}
			}
		} catch {}
	}

	/// Update app user token.
	/// - throws: network errors
	private func updateToken() async throws {
		guard var auth = self.auth else { throw AppError.logout }
		self.tokenStatus = .loading
		let (refreshToken, userToken) = try await withCheckedThrowingContinuation { continuation in
			self.asyncUpdateToken(auth: auth, continuation: continuation)
		}
		auth.refreshToken = refreshToken
		auth.userToken = userToken

		tokenStatus = .aquired(Date())
		self.auth = auth
	}

	// MARK: helpers

	/// Logout the user. Shuts down the SDK until next MoveSDK.setup.
	private func logout() {
		resolveContinuations(error: AppError.logout)
		auth = nil

		DispatchQueue.main.async {
			self.userID = nil
			SDKManager.shared.shutdown()
		}
	}

	/// Extract SDK MoveAuth from ApiLogin.
	private func getSDKAuth(login: ApiLogin?) -> MoveAuth? {
		guard let data = login,
			  let sdkLogin = data.sdkUserLoginInfo,
			  let sdkUserToken = sdkLogin.accessToken,
			  let sdkRefreshToken = sdkLogin.refreshToken,
			  let projectID = sdkLogin.productId,
			  let sdkUserID = sdkLogin.contractId
		else {
			return nil
		}

		return MoveAuth(userToken: sdkUserToken, refreshToken: sdkRefreshToken, userID: sdkUserID, projectID: Int64(projectID))
	}

	/// Convert ApiLogin to Authentication object.
	private func getAuth(login: ApiLogin?) -> Authentication? {
		guard let data = login,
			  let userID = data.contractId,
			  let productAuth = data.productAuthInfo,
			  let userToken = productAuth.accessToken,
			  let refreshToken = productAuth.refreshToken
		else {
			return nil
		}
		return Authentication(refreshToken: refreshToken, userToken: userToken, userID: userID)
	}

	/// Resolve pending requests.
	private func resolveContinuations(error: Error? = nil) {
		let continuations = pendingContinuations
		pendingContinuations.removeAll()
		if let error = error {
			for continuation in continuations {
				continuation.resume(throwing: error)
			}
		} else {
			for continuation in continuations {
				continuation.resume()
			}
		}
	}

	/// Try using current token or wait for new token,
	/// by adding to the on the pending requests queue.
	private func awaitToken() async throws {
		if tokenStatus.isValid {
			return
		} else {
			if !tokenStatus.isLoading {
				do {
					try await updateToken()
					resolveContinuations()
				} catch {
					resolveContinuations(error: error)
				}
			} else {
				/* enqueue */
				try await withCheckedThrowingContinuation { continuation in
					pendingContinuations.append(continuation)
				}
			}
		}
	}

	/// Wrapper to convert non logged in request with continuation to async method.
	private func asyncRequest<T>(_ request: @escaping(CheckedContinuation<T, Error>)->Void) async throws -> T {
		return try await withCheckedThrowingContinuation { continuation in
			request(continuation)
		}
	}

	/// Wrapper to convert authenticated request with continuation to async method.
	/// Token refresh will be automatic and cause an immediate retry.
	private func asyncAuthenticatedRequest<T>(_ request: @escaping(CheckedContinuation<T, Error>)->Void) async throws -> T {
		repeat {
			do {
				if self.auth == nil {
					/* a logout could have happened and header will not be filled in
					 * sending anyway would loop with a 401 : "token expired" response */
					throw AppError.cancelled
				}
				/* make sure we have a valid tooken */
				try await awaitToken()
				/* return response */
				return try await withCheckedThrowingContinuation { continuation in
					request(continuation)
				}
			} catch AppError.logout {
				logout()
				throw AppError.logout
			} catch AppError.tokenExpired {
				/* double check if token was recently fetched */
				if !tokenStatus.isFresh {
					tokenStatus = .expired
				}
				/* continue looping */
			} catch {
				throw error
			}
		} while true
	}
}

// MARK: Async API
extension AppManager {
	/* Async functions convert generated callback based swagger API to coroutines. */

	private func asyncRegister(gender: String, firstname: String, lastname: String, phone: String?, company: String?, email: String, password: String, continuation: CheckedContinuation<ApiLogin, Error>) {

		let consents = [
			ApiUserConsent(state: true, type: "privacy"),
			ApiUserConsent(state: true, type: "tou")
		]

		let body = ApiRegisterUserRequest(company: company, consents: consents, email: email, firstName: firstname, gender: gender, lastName: lastname, password: password, phone: phone)
		let request = API.MoveUserRest.PostApiV1Users.Request(body: body)
		setupHeaders(for: request, authenticated: false)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				print("\(res)")
				if let data = res.success?.data {
					continuation.resume(returning: data)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.networkError)
				}
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncLogin(email: String, password: String, continuation: CheckedContinuation<ApiLogin, Error>) {
		let body = ApiLoginRequest(email: email, password: password)
		let request = API.MoveUserRest.PostApiV1UsersLogin.Request(body: body)
		setupHeaders(for: request, authenticated: false)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				if let data = res.success?.data {
					continuation.resume(returning: data)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.networkError)
				}
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncDeleteUser(password: String, continuation: CheckedContinuation<Void, Error>) {
		let body = ApiDeleteAccountRequest(password: password)
		let request = API.MoveUserRest.PostApiV1UsersDelete.Request(body: body)
		setupHeaders(for: request)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				print("\(res)")
				if res.success != nil {
					continuation.resume()
				} else if res.statusCode == 400 {
					continuation.resume(throwing: AppError.logout)
				} else if res.statusCode == 401 {
					continuation.resume(throwing: AppError.tokenExpired)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.networkError)
				}
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncGetUser(continuation: CheckedContinuation<ApiContract, Error>) {
		let request = API.MoveUserRest.GetApiV1Users.Request()
		setupHeaders(for: request)

		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				print("\(res)")
				if let contract = res.success?.data {
					continuation.resume(returning: contract)
				} else if res.statusCode == 400 {
					continuation.resume(throwing: AppError.logout)
				} else if res.statusCode == 401 {
					continuation.resume(throwing: AppError.tokenExpired)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.networkError)
				}
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncUpdateUserEmail(_ email: String, password: String, gender: String, firstname: String, lastname: String, phonennumber: String?, company: String?, continuation: CheckedContinuation<Void, Error>) {
		let body = ApiChangeContractDataRequest(company: company, email: email, firstName: firstname, gender: gender, lastName: lastname, password: password, phone: phonennumber)

		let request = API.MoveUserRest.PutApiV1UsersEmail.Request(body: body)
		setupHeaders(for: request)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				print("\(res)")
				if res.success != nil {
					continuation.resume()
				} else if res.statusCode == 400 {
					continuation.resume(throwing: AppError.logout)
				} else if res.statusCode == 401 {
					continuation.resume(throwing: AppError.tokenExpired)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.networkError)
				}
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncUpdateUserProfile(gender: String, firstname: String, lastname: String, phonennumber: String?, company: String?, continuation: CheckedContinuation<Void, Error>) {
		let body = ApiChangeContractDataRequest(company: company, firstName: firstname, gender: gender, lastName: lastname, phone: phonennumber)

		let request =  API.MoveUserRest.PatchApiV1Users.Request(body: body)
		setupHeaders(for: request)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				print("\(res)")
				if res.success?.data != nil {
					continuation.resume()
				} else if res.statusCode == 400 {
					continuation.resume(throwing: AppError.logout)
				} else if res.statusCode == 401 {
					continuation.resume(throwing: AppError.tokenExpired)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.networkError)
				}
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncRequestChangePassword(old: String, new: String, continuation: CheckedContinuation<Void, Error>) {
		let body = ApiChangePasswordRequest(newPassword: new, password: old)
		let request = API.MoveUserRest.PutApiV1UsersPasswords.Request(body: body)
		setupHeaders(for: request)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				if res.success != nil {
					continuation.resume()
				} else if res.statusCode == 400 {
					continuation.resume(throwing: AppError.logout)
				} else if res.statusCode == 401 {
					continuation.resume(throwing: AppError.tokenExpired)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.networkError)
				}
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncRequestForgotPassword(email: String, continuation: CheckedContinuation<Void, Error>) {
		let body = ApiRequestResetPasswordRequest(email: email)
		let request = API.MoveUserRest.PostApiV1UsersPasswordsResets.Request(body: body)
		setupHeaders(for: request, authenticated: false)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				if res.success != nil {
					continuation.resume()
				} else if res.statusCode == 400 {
					continuation.resume(throwing: AppError.logout)
				} else if res.statusCode == 401 {
					continuation.resume(throwing: AppError.tokenExpired)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.networkError)
				}
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncRequestMessages(continuation: CheckedContinuation<[ApiMessage], Error>) {
		let request = API.PushRest.GetApiV1Messages.Request()
		setupHeaders(for: request)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				if let messages = res.success?.data?.messages {
					continuation.resume(returning: messages)
				} else if res.statusCode == 400 {
					continuation.resume(throwing: AppError.logout)
				} else if res.statusCode == 401 {
					continuation.resume(throwing: AppError.tokenExpired)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.networkError)
				}
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncSynchronizeMessages(_ messages: [Message], continuation: CheckedContinuation<Void, Error>) {
		let apiMessages: [ApiMessage] = messages.map { ApiMessage(deleted: $0.deleted, id: $0.id, read: $0.read) }
		let body = ApiUpdateMessagesRequest(messages: apiMessages)
		let request = API.PushRest.PatchApiV1Messages.Request(body: body)
		setupHeaders(for: request)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				if res.success != nil {
					continuation.resume()
				} else if res.statusCode == 400 {
					continuation.resume(throwing: AppError.logout)
				} else if res.statusCode == 401 {
					continuation.resume(throwing: AppError.tokenExpired)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.networkError)
				}
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncGetTimeline(from: Date, to: Date, continuation: CheckedContinuation<[ApiMoveTimelineItemBase], Error>) {
		let request = API.TimelineRest.GetApiV1Timeline.Request(from: Int(from.timeIntervalSince1970), to: Int(to.timeIntervalSince1970))
		setupHeaders(for: request)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				if let items = res.success?.data?.timelineItemBaseList {
					continuation.resume(returning: items)
				} else if res.statusCode == 400 {
					continuation.resume(throwing: AppError.logout)
				} else if res.statusCode == 401 {
					continuation.resume(throwing: AppError.tokenExpired)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.networkError)
				}
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncGetTripDetails(id: Int, continuation: CheckedContinuation<ApiMoveTimelineItemDetail, Error>) {
		let request = API.TimelineRest.GetApiV1TimelineByIdDetails.Request(id: id)
		setupHeaders(for: request)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				if let details = res.success?.data?.tripDetail {
					continuation.resume(returning: details)
				} else if res.statusCode == 400 {
					continuation.resume(throwing: AppError.logout)
				} else if res.statusCode == 401 {
					continuation.resume(throwing: AppError.tokenExpired)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.networkError)
				}
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncUpdateToken(auth: Authentication, continuation: CheckedContinuation<(String, String), Error>) {
		let timestamp = Date()
		let date = formatter.string(from: timestamp)
		let body = ApiRefreshTokenRequest(timestamp: Int(timestamp.timeIntervalSince1970), appId: appid, clientVersion: version, contractId: auth.userID, isoTime: date, language: language, platform: platform, uuid: UUID().uuidString, refreshToken: auth.refreshToken)
		let request = API.MoveUserRest.PostApiV1UsersTokensProducts.Request(body: body)
		setupHeaders(for: request, authenticated: false)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				print("\(res)")
				guard let data = res.success?.data,
					  let productAuth = data.productAuthInfo,
					  let userToken = productAuth.accessToken,
					  let refreshToken = productAuth.refreshToken
				else {
					/// Logout
					continuation.resume(throwing: AppError.logout)
					return
				}

				continuation.resume(returning: (refreshToken, userToken))
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncUpdateSDKToken(continuation: CheckedContinuation<MoveAuth, Error>) {
		let request = API.MoveUserRest.GetApiV1UsersTokensSdks.Request()
		setupHeaders(for: request)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				if let sdkLogin = res.success?.data?.sdkUserLoginInfo,
				   let sdkUserToken = sdkLogin.accessToken,
				   let sdkRefreshToken = sdkLogin.refreshToken,
				   let projectID = sdkLogin.productId,
				   let userID = sdkLogin.contractId {

					let sdkAuth = MoveAuth(userToken: sdkUserToken, refreshToken: sdkRefreshToken, userID: userID, projectID: Int64(projectID))
					continuation.resume(returning: sdkAuth)
				} else if res.statusCode == 400 {
					continuation.resume(throwing: AppError.logout)
				} else if res.statusCode == 401 {
					continuation.resume(throwing: AppError.tokenExpired)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.parserError)
				}
			case let .failure(error):
				print("\(error)")
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}

	private func asyncSetPushToken(_ pushToken: String, continuation: CheckedContinuation<Void, Error>) {
		let tokenType: String
		#if DEBUG
		tokenType = "sandbox"
		#else
		tokenType = "production"
		#endif

		let body = ApiAddDeviceTokenRequest(deviceToken: pushToken, deviceTokenBundle: Bundle.main.bundleIdentifier, deviceTokenType: tokenType)

		let request = API.PushRest.PostApiV1MessagesTokens.Request(body: body)
		setupHeaders(for: request)
		request.makeRequest { response in
			switch response.result {
			case let .success(res):
				if res.success != nil {
					continuation.resume()
				} else if res.statusCode == 400 {
					continuation.resume(throwing: AppError.logout)
				} else if res.statusCode == 401 {
					continuation.resume(throwing: AppError.tokenExpired)
				} else if let message = res.failure?.status?.message ?? res.success?.status?.message {
					continuation.resume(throwing: AppError.serverError(message))
				} else {
					continuation.resume(throwing: AppError.tokenExpired)
				}
			case .failure:
				continuation.resume(throwing: AppError.networkError)
			}
		}
	}
}
