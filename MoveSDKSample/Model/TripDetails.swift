/*
 *  Copyright 2023 Dolphin Technologies GmbH
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http:*www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 * /
 */

import CoreLocation
import SwiftUI

class TripDetails: Identifiable, Equatable {
	enum Weight {
		case low
		case medium
		case high
		init(_ value: ApiColour?) {
			switch value {
			case .yellow:
				self = .medium
			case .red:
				self = .high
			default:
				self = .low
			}
		}

		init(_ weight: Int) {
			switch weight {
			case 6...:
				self = .high
			case 3...:
				self = .medium
			default:
				self = .low
			}
		}
	}

	struct Location {
		let coordinate: CLLocationCoordinate2D
		let weight: Weight
		let speed: Int
		let limit: Int
		let timestamp: Date
	}

	struct Event {
		enum Category: CaseIterable {
			case cornering
			case braking
			case acceleration

			init(_ value: ApiDBEType?) {
				switch value {
				case .brk:
					self = .braking
				case .crn:
					self = .cornering
				default:
					self = .acceleration
				}
			}
		}

		let coordinate: CLLocationCoordinate2D
		let value: Int
		let weight: Weight
		let type: Category
	}

	struct Segment: Identifiable {
		enum Category: CaseIterable {
			case undistracted
			case phone
			case swipeAndType
		}

		let id: Int
		let type: Category
		let start: Date
		let end: Date
		let duration: Int

		let startOffset: CGFloat
		let endOffset: CGFloat
	}

	static func == (lhs: TripDetails, rhs: TripDetails) -> Bool {
		lhs === rhs
	}

	/// Trip.
	let trip: TimelineEventModel

	/// Location points of trip.
	let locations: [Location]

	/// Driving behavior events during trip.
	let events: [Event]

	/// Distraction event segments to display.
	let segments: [Segment]

	/// Driving behavior score.
	let ecoScore: Int

	/// Distraction score.
	let distractionScore: Int

	/// Speeding score.
	let speedScore: Int

	/// Not Speeding.
	let greenKm: Int

	/// Speeding.
	let yellowKm: Int

	/// Dangerous Speeding.
	let redKm: Int

	/// Acceleration behavior categorization.
	let accelerationCount: (Int, Int, Int)

	/// Breaking behavior categorization.
	let brakingCount: (Int, Int, Int)

	/// Cornering behavior categorization.
	let corneringCount: (Int, Int, Int)

	/// Distraction free time in minutes.
	let distactionFreeMinutes: Int

	/// Distracted time in minutes.
	let distractedMinutes: Int

	/// Static initializer, for previews only.
	init() {
		trip = TimelineEventModel()
		locations = []
		events = []

		ecoScore = 76
		distractionScore = 45
		speedScore = 23

		greenKm = 76
		yellowKm = 45
		redKm = 23

		accelerationCount = (2, 3, 0)
		brakingCount = (0, 2, 1)
		corneringCount = (0, 4, 0)

		distractedMinutes = 5
		distactionFreeMinutes = 7

		self.segments = Array<Int>(0 ..< 5).map {
			let type = Segment.Category.allCases.randomElement()!
			return Segment(id: $0, type: type, start: Date(), end: Date(), duration: 0, startOffset: CGFloat($0) / CGFloat(5), endOffset: CGFloat($0+1) / CGFloat(5))
		}
	}

	/// Extract trip details from API.
	/// - parameters:
	///    - trip: Trip to append details to.
	///    - details: Autogenerated API object.
	init(trip: TimelineEventModel, details: ApiMoveTimelineItemDetail) {
		self.trip = trip

		self.locations = details.tripPoints?.map {
			let lat = CLLocationDegrees($0.lat ?? "") ?? 0.0
			let lon = CLLocationDegrees($0.lon ?? "") ?? 0.0
			let coord = CLLocationCoordinate2D(latitude: lat, longitude: lon)
			let time = TimelineModel.shared.parseformatter.date(from: $0.isoTime!)!

			return Location(coordinate: coord, weight: .init($0.colour), speed: $0.speed ?? 0, limit: $0.speedLimit ?? 0, timestamp: time)
		} ?? []

		self.events = details.drivingEvents?.map {
			let lat = CLLocationDegrees($0.lat ?? 0.0)
			let lon = CLLocationDegrees($0.lon ?? 0.0)
			let coord = CLLocationCoordinate2D(latitude: lat, longitude: lon)

			return Event(coordinate: coord, value: $0.value, weight: Weight($0.value), type: .init($0.type))
		} ?? []

		let duration = trip.end.timestamp.timeIntervalSince(trip.start.timestamp)
		func calculateOffset(_ date: Date) -> CGFloat {
			let delta = date.timeIntervalSince(trip.start.timestamp)
			return delta / duration
		}

		var id = 0
		var segments: [Segment] = []
		var date = trip.start.timestamp
		for segment in details.distractionEvents ?? [] {
			let startTs = TimelineModel.shared.parseformatter.date(from: segment.startIsoTime!)!
			let endTs = TimelineModel.shared.parseformatter.date(from: segment.endIsoTime!)!
			if date < startTs {
				segments.append(Segment(id: id, type: .undistracted, start: date, end: startTs, duration: 0, startOffset: calculateOffset(date), endOffset: calculateOffset(startTs)))
				id += 1
			}

			segments.append(Segment(id: id, type: segment.type == .phHheld ? .phone : .swipeAndType, start: startTs, end: endTs, duration: segment.durationMinutes ?? 0, startOffset: calculateOffset(startTs), endOffset: calculateOffset(endTs)))
			id += 1
			date = endTs
		}

		if date < trip.end.timestamp {
			segments.append(Segment(id: id, type: .undistracted, start: date, end: trip.end.timestamp, duration: 0, startOffset: calculateOffset(date), endOffset: calculateOffset(trip.end.timestamp)))
		}

		self.segments = segments

		let accelerations = self.events.filter { $0.type == .acceleration }
		let brakings = self.events.filter { $0.type == .braking }
		let cornerings = self.events.filter { $0.type == .braking }

		accelerationCount = (
			accelerations.filter { $0.weight == .low }.count,
			accelerations.filter { $0.weight == .medium }.count,
			accelerations.filter { $0.weight == .high }.count)

		brakingCount = (
			brakings.filter { $0.weight == .low }.count,
			brakings.filter { $0.weight == .medium }.count,
			brakings.filter { $0.weight == .high }.count)

		corneringCount = (
			cornerings.filter { $0.weight == .low }.count,
			cornerings.filter { $0.weight == .medium }.count,
			cornerings.filter { $0.weight == .high }.count)

		ecoScore = details.scores?.safeness ?? 100
		distractionScore = details.scores?.distraction ?? 100
		speedScore = details.scores?.speed ?? 100

		greenKm = details.sectionDistance?.green ?? 0
		yellowKm = details.sectionDistance?.yellow ?? 0
		redKm = details.sectionDistance?.red ?? 0

		distractedMinutes = details.distractionDetails?.totalDistractedMinutes ?? 0
		distactionFreeMinutes = details.distractionDetails?.distractionFreeMinutes ?? 0
	}
}
